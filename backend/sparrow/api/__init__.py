from flask import Flask, Blueprint
from flask_restful import Resource, reqparse, inputs
from sqlalchemy.schema import Table
from sqlalchemy import MetaData
from flask_jwt_extended import jwt_required
from textwrap import dedent

from .base import API

# eventually should use **Marshmallow** or similar
# for parsing incoming API requests

def infer_primary_key(table):
    pk = table.primary_key
    if len(pk) == 1:
        return list(pk)[0]
    # Check PK column a few possible ways
    for i in ('id', table.name+'_id'):
        pk = table.c.get(i, None)
        if pk is not None: return pk
    return list(table.c)[0]

def infer_type(t):
    # Really hackish
    type = t.type.python_type
    if type == bool:
        type = inputs.boolean
    return type

def build_description(argument):
    """
    Build a description for a parser argument
    """
    type = argument.type
    usage = None
    typename = type.__name__
    if typename == 'Decimal':
        typename = 'numeric'
    elif type == list:
        typename = 'array'
        usage = "Match any of the array items"
    elif type == str:
        usage = dedent("""
        Use [*PostgreSQL* **LIKE** wildcards](https://www.postgresql.org/docs/current/functions-matching.html)
        (e.g. %,_,*) for fuzzy matching
        """)

    return dict(
        name=argument.name,
        default=argument.default,
        type=typename,
        description=argument.help,
        usage=usage
    )

class APIv1(API):
    """
    Version 1 API for Lab Data Interface

    Includes functionality for autogenerating routes
    from database tables and views.

    Each autogenerated endpoint has a `/describe` URL that
    provides API usage data.
    """
    def __init__(self, database):
        self.db = database
        self.blueprint = Blueprint('api', __name__)
        super().__init__(self.blueprint)
        self.route_descriptions = []
        self.create_description_model()

    def create_description_model(self):
        route_descriptions = self.route_descriptions
        class APIDescriptionModel(Resource):
            def get(self):
                return dict(
                    route='/api/v1',
                    description='Version 1 API for Lab Data Interface',
                    routes=route_descriptions)

        self.add_resource(APIDescriptionModel, '/', '/describe')


    def build_route(self, tablename, **kwargs):
        schema = kwargs.pop('schema', None)
        db = self.db
        table = db.reflect_table(tablename, schema=schema)

        schema_qualified_tablename = tablename
        if schema is not None:
            schema_qualified_tablename = schema+"."+schema_qualified_tablename
        description = f"Autogenerated route for table `{schema_qualified_tablename}`"

        primary_key = kwargs.pop("primary_key", None)
        if primary_key is not None:
            key = table.c[primary_key]
        else:
            key = infer_primary_key(table)

        parser = reqparse.RequestParser()
        parser.add_argument('offset', type=int, help='Query offset', default=None)
        parser.add_argument('limit', type=int, help='Query limit', default=None)

        parser.add_argument('all', type=bool, help='Return all rows', default=False)

        for name, column in table.c.items():
            try:
                type = infer_type(column)
                if type == dict:
                    # We don't yet support dict types
                    continue
                typename = type.__name__
                parser.add_argument(name, type=type,
                    help=f"Column '{name}' of type '{typename}'")
            except: pass

        # Set up information about
        # table descriptions

        route = f"/{tablename}"
        tname = infer_type(key).__name__
        if tname != 'int':
            tname = 'string'
        get_route = f"/<{tname}:{key.name}>"

        basicInfo = dict(
            route=route,
            table=table.name,
            schema=table.schema,
            description=description,
            usage_info="Pass the parameter `?all=1` to return all rows instead of API description"
        )
        self.route_descriptions.append(basicInfo)


        class TableModel(Resource):
            def describe(self):
                """
                If no parameters are passed, return the API route's
                description object. This conforms to the convention
                of the Macrostrat API.
                """
                args = [build_description(a) for a in parser.args]

                return dict(
                    **basicInfo,
                    arguments=args,
                    record=dict(
                        route=get_route,
                        key=key.name,
                        type=tname))

            @jwt_required
            def get(self):
                args = parser.parse_args()
                print(args)
                q = db.session.query(table)

                should_describe = True
                for k,col in table.c.items():
                    val = args.pop(k, None)
                    if val is not None:
                        should_describe = False
                        if col.type.python_type == str:
                            q = q.filter(col.like(val))
                        else:
                            q = q.filter(col==val)

                if args.pop('all', False):
                    should_describe = False

                count = q.count()

                for k in ('offset','limit'):
                    val = args.pop(k, None)
                    if val is not None:
                        should_describe = False
                        q = getattr(q,k)(val)

                if should_describe:
                    return self.describe()

                # Save the count of the query
                response = q.all()
                status = 200
                headers = {'x-total-count': count}
                return response, status, headers

        class RecordModel(Resource):
            @jwt_required
            def get(self, id):
                # Should fail if more than one record is returned
                return (db.session.query(table)
                    .filter(key==id)
                    .first())

        # Dynamically change class name,
        # this kind of metaprogrammy wizardry
        # may cause problems later
        TableModel.__name__ = tablename
        RecordModel.__name__ = tablename+'_record'

        self.add_resource(TableModel, route, route+"/")
        self.add_resource(RecordModel, get_route)
